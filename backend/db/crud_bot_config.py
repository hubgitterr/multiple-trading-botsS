# backend/db/crud_bot_config.py
from sqlalchemy.orm import Session
from sqlalchemy.dialects.postgresql import UUID
from typing import List, Optional, Dict, Any
import logging

from backend.models.bot_config import BotConfig # Import the model
# Import Pydantic schemas later if needed for validation/serialization
# from backend.schemas import BotConfigCreate, BotConfigUpdate 

logger = logging.getLogger(__name__)

def get_bot_config(db: Session, config_id: UUID, user_id: str) -> Optional[BotConfig]:
    """Gets a specific bot configuration by ID, ensuring user ownership."""
    logger.debug(f"Fetching bot config: id={config_id}, user_id={user_id}")
    return db.query(BotConfig).filter(BotConfig.id == config_id, BotConfig.user_id == user_id).first()

def get_bot_configs_by_user(db: Session, user_id: str, skip: int = 0, limit: int = 100) -> List[BotConfig]:
    """Gets all bot configurations for a specific user."""
    logger.debug(f"Fetching bot configs for user_id={user_id}, skip={skip}, limit={limit}")
    return db.query(BotConfig).filter(BotConfig.user_id == user_id).offset(skip).limit(limit).all()

def create_bot_config(db: Session, user_id: str, config_data: Dict[str, Any]) -> BotConfig:
    """Creates a new bot configuration."""
    # **IMPORTANT**: Ensure config_data is validated (e.g., using Pydantic) before this step in the API route
    logger.info(f"Creating bot config for user_id={user_id}: type={config_data.get('bot_type')}, symbol={config_data.get('symbol')}")
    db_config = BotConfig(
        user_id=user_id,
        bot_type=config_data.get("bot_type"),
        name=config_data.get("name"), # Add name if provided
        symbol=config_data.get("symbol"),
        settings=config_data.get("settings", {}),
        is_enabled=config_data.get("is_enabled", True) 
        # id is generated by default
    )
    db.add(db_config)
    db.commit()
    db.refresh(db_config)
    logger.info(f"Bot config created successfully: id={db_config.id}")
    return db_config

def update_bot_config(db: Session, config_id: UUID, user_id: str, update_data: Dict[str, Any]) -> Optional[BotConfig]:
    """Updates an existing bot configuration."""
    # **IMPORTANT**: Ensure update_data is validated before this step
    logger.info(f"Updating bot config id={config_id} for user_id={user_id}")
    db_config = get_bot_config(db, config_id=config_id, user_id=user_id)
    if not db_config:
        logger.warning(f"Bot config id={config_id} not found for user_id={user_id} during update.")
        return None
    
    update_values = update_data.copy() # Work on a copy
    # Prevent changing immutable fields like id, user_id, created_at
    update_values.pop('id', None)
    update_values.pop('user_id', None)
    update_values.pop('created_at', None)
    
    for key, value in update_values.items():
         if hasattr(db_config, key):
              setattr(db_config, key, value)
         else:
              logger.warning(f"Attempted to update non-existent field '{key}' on BotConfig.")

    db.commit()
    db.refresh(db_config)
    logger.info(f"Bot config updated successfully: id={db_config.id}")
    return db_config

def delete_bot_config(db: Session, config_id: UUID, user_id: str) -> bool:
    """Deletes a bot configuration."""
    logger.info(f"Deleting bot config id={config_id} for user_id={user_id}")
    db_config = get_bot_config(db, config_id=config_id, user_id=user_id)
    if not db_config:
        logger.warning(f"Bot config id={config_id} not found for user_id={user_id} during delete.")
        return False
    
    db.delete(db_config)
    db.commit()
    logger.info(f"Bot config deleted successfully: id={config_id}")
    return True